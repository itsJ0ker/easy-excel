import * as XLSX from 'xlsx';
import type { Column, DataRow, ExportOptions, CellStyle } from '../types';
import { exportToExcelWithFormatting } from './excelExport';

export const exportToExcel = async (
  fileName: string,
  columns: Column[],
  rows: DataRow[],
  options: ExportOptions
) => {
  // Use ExcelJS for better formatting support
  if (options.includeFormatting) {
    await exportToExcelWithFormatting(fileName, columns, rows, options);
    return;
  }

  // Fallback to basic XLSX export for non-formatted files
  const wsData = [];
  
  // Add headers if requested
  if (options.includeHeaders) {
    wsData.push(columns.map(col => col.name));
  }

  // Add data rows
  rows.forEach(row => {
    const rowData = columns.map(col => {
      const value = row.data[col.id] || '';
      return formatForExport(value, col, options);
    });
    wsData.push(rowData);
  });

  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.aoa_to_sheet(wsData);

  // Set column widths
  const colWidths = columns.map(col => ({ wch: col.width || 15 }));
  ws['!cols'] = colWidths;

  // Apply Excel features
  if (options.autoFilter && options.includeHeaders) {
    const range = XLSX.utils.decode_range(ws['!ref'] || 'A1');
    ws['!autofilter'] = { ref: XLSX.utils.encode_range(range) };
  }

  if (options.freezeHeader && options.includeHeaders) {
    ws['!freeze'] = { xSplit: 0, ySplit: 1 };
  }

  XLSX.utils.book_append_sheet(wb, ws, options.sheetName || 'Sheet1');

  // Set workbook properties
  wb.Props = {
    Title: fileName,
    Subject: 'Generated by Easy Excel',
    Author: 'Easy Excel',
    CreatedDate: new Date()
  };

  const fileNameWithExt = fileName.endsWith('.xlsx') ? fileName : `${fileName}.xlsx`;
  XLSX.writeFile(wb, fileNameWithExt);
};

const applyCellFormatting = (
  ws: XLSX.WorkSheet, 
  cellAddress: string, 
  style: CellStyle, 
  column?: Column
) => {
  if (!ws[cellAddress]) return;

  const cell = ws[cellAddress];
  
  // Initialize cell style object
  if (!cell.s) cell.s = {};

  // Font formatting
  if (style.bold || style.italic || style.fontSize || style.fontFamily || style.textColor) {
    cell.s.font = {
      bold: style.bold || false,
      italic: style.italic || false,
      underline: style.underline || false,
      sz: style.fontSize || 12,
      name: style.fontFamily || 'Arial',
      color: style.textColor ? { rgb: style.textColor.replace('#', '') } : undefined
    };
  }

  // Background color
  if (style.backgroundColor) {
    cell.s.fill = {
      fgColor: { rgb: style.backgroundColor.replace('#', '') },
      patternType: 'solid'
    };
  }

  // Alignment
  if (style.textAlign || style.verticalAlign) {
    cell.s.alignment = {
      horizontal: style.textAlign || 'left',
      vertical: style.verticalAlign || 'bottom',
      wrapText: true
    };
  }

  // Borders
  if (style.border) {
    cell.s.border = {};
    if (style.border.top) {
      cell.s.border.top = {
        style: style.border.top.style,
        color: { rgb: style.border.top.color.replace('#', '') }
      };
    }
    if (style.border.bottom) {
      cell.s.border.bottom = {
        style: style.border.bottom.style,
        color: { rgb: style.border.bottom.color.replace('#', '') }
      };
    }
    if (style.border.left) {
      cell.s.border.left = {
        style: style.border.left.style,
        color: { rgb: style.border.left.color.replace('#', '') }
      };
    }
    if (style.border.right) {
      cell.s.border.right = {
        style: style.border.right.style,
        color: { rgb: style.border.right.color.replace('#', '') }
      };
    }
  }

  // Number format
  if (style.numberFormat) {
    cell.z = style.numberFormat;
  } else if (column) {
    // Apply default formatting based on column type
    switch (column.type) {
      case 'currency':
        cell.z = column.format?.currency === 'EUR' ? '€#,##0.00' : 
                 column.format?.currency === 'GBP' ? '£#,##0.00' : 
                 '"$"#,##0.00';
        break;
      case 'percentage':
        cell.z = '0.00%';
        break;
      case 'date':
        cell.z = column.format?.dateFormat || 'mm/dd/yyyy';
        break;
      case 'number':
        const decimals = column.format?.decimalPlaces || 2;
        cell.z = decimals > 0 ? `#,##0.${'0'.repeat(decimals)}` : '#,##0';
        break;
    }
  }
};

export const exportToCSV = (
  fileName: string,
  columns: Column[],
  rows: DataRow[],
  options: ExportOptions
) => {
  let csvContent = '';
  
  if (options.includeHeaders) {
    csvContent += columns.map(col => `"${col.name}"`).join(',') + '\n';
  }

  rows.forEach(row => {
    const rowData = columns.map(col => {
      const value = row.data[col.id] || '';
      const formatted = formatForExport(value, col, options);
      return `"${formatted.replace(/"/g, '""')}"`;
    });
    csvContent += rowData.join(',') + '\n';
  });

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', fileName.endsWith('.csv') ? fileName : `${fileName}.csv`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

export const exportToJSON = (
  fileName: string,
  columns: Column[],
  rows: DataRow[],
  options: ExportOptions
) => {
  const jsonData = rows.map(row => {
    const obj: Record<string, any> = {};
    columns.forEach(col => {
      const value = row.data[col.id] || '';
      obj[col.name] = formatForExport(value, col, options);
    });
    return obj;
  });

  const jsonString = JSON.stringify(jsonData, null, 2);
  const blob = new Blob([jsonString], { type: 'application/json' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', fileName.endsWith('.json') ? fileName : `${fileName}.json`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

const formatForExport = (value: string, column: Column, options: ExportOptions): string => {
  if (!value.trim()) return value;

  switch (column.type) {
    case 'date':
      const dateValue = new Date(value);
      if (!isNaN(dateValue.getTime())) {
        return dateValue.toLocaleDateString('en-US', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit'
        });
      }
      break;
    case 'number':
    case 'currency':
    case 'percentage':
      const numValue = parseFloat(value);
      if (!isNaN(numValue)) {
        return numValue.toString();
      }
      break;
  }

  return value;
};