import * as XLSX from 'xlsx';
import type { Column, DataRow, ExportOptions } from '../types';
import { exportToExcelWithFormatting } from './excelExport';

export const exportToExcel = async (
  fileName: string,
  columns: Column[],
  rows: DataRow[],
  options: ExportOptions
) => {
  // Use ExcelJS for better formatting support
  if (options.includeFormatting) {
    await exportToExcelWithFormatting(fileName, columns, rows, options);
    return;
  }

  // Fallback to basic XLSX export for non-formatted files
  const wsData = [];
  
  // Add headers if requested
  if (options.includeHeaders) {
    wsData.push(columns.map(col => col.name));
  }

  // Add data rows
  rows.forEach(row => {
    const rowData = columns.map(col => {
      const value = row.data[col.id] || '';
      return formatForExport(value, col);
    });
    wsData.push(rowData);
  });

  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.aoa_to_sheet(wsData);

  // Set column widths
  const colWidths = columns.map(col => ({ wch: col.width || 15 }));
  ws['!cols'] = colWidths;

  // Apply Excel features
  if (options.autoFilter && options.includeHeaders) {
    const range = XLSX.utils.decode_range(ws['!ref'] || 'A1');
    ws['!autofilter'] = { ref: XLSX.utils.encode_range(range) };
  }

  if (options.freezeHeader && options.includeHeaders) {
    ws['!freeze'] = { xSplit: 0, ySplit: 1 };
  }

  XLSX.utils.book_append_sheet(wb, ws, options.sheetName || 'Sheet1');

  // Set workbook properties
  wb.Props = {
    Title: fileName,
    Subject: 'Generated by Easy Excel',
    Author: 'Easy Excel',
    CreatedDate: new Date()
  };

  const fileNameWithExt = fileName.endsWith('.xlsx') ? fileName : `${fileName}.xlsx`;
  XLSX.writeFile(wb, fileNameWithExt);
};

// Note: This function is kept for potential future use with XLSX library
// Currently using ExcelJS for better formatting support
// const applyCellFormatting = (
//   ws: XLSX.WorkSheet, 
//   cellAddress: string, 
//   style: CellStyle, 
//   column?: Column
// ) => {
//   // Implementation available but not used in current version
// };

export const exportToCSV = (
  fileName: string,
  columns: Column[],
  rows: DataRow[],
  options: ExportOptions
) => {
  let csvContent = '';
  
  if (options.includeHeaders) {
    csvContent += columns.map(col => `"${col.name}"`).join(',') + '\n';
  }

  rows.forEach(row => {
    const rowData = columns.map(col => {
      const value = row.data[col.id] || '';
      const formatted = formatForExport(value, col);
      return `"${formatted.replace(/"/g, '""')}"`;
    });
    csvContent += rowData.join(',') + '\n';
  });

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', fileName.endsWith('.csv') ? fileName : `${fileName}.csv`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

export const exportToJSON = (
  fileName: string,
  columns: Column[],
  rows: DataRow[]
) => {
  const jsonData = rows.map(row => {
    const obj: Record<string, any> = {};
    columns.forEach(col => {
      const value = row.data[col.id] || '';
      obj[col.name] = formatForExport(value, col);
    });
    return obj;
  });

  const jsonString = JSON.stringify(jsonData, null, 2);
  const blob = new Blob([jsonString], { type: 'application/json' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', fileName.endsWith('.json') ? fileName : `${fileName}.json`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

const formatForExport = (value: string, column: Column): string => {
  if (!value.trim()) return value;

  switch (column.type) {
    case 'date':
      const dateValue = new Date(value);
      if (!isNaN(dateValue.getTime())) {
        return dateValue.toLocaleDateString('en-US', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit'
        });
      }
      break;
    case 'number':
    case 'currency':
    case 'percentage':
      const numValue = parseFloat(value);
      if (!isNaN(numValue)) {
        return numValue.toString();
      }
      break;
  }

  return value;
};